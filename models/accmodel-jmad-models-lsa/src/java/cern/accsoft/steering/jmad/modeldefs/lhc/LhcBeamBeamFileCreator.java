package cern.accsoft.steering.jmad.modeldefs.lhc;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import cern.accsoft.steering.jmad.domain.elem.Element;
import cern.accsoft.steering.jmad.domain.elem.MadxElementType;
import cern.accsoft.steering.jmad.domain.elem.Position;
//import cern.accsoft.steering.jmad.domain.elem.RelativePosition;
import cern.accsoft.steering.jmad.domain.elem.impl.BeamBeam;
import cern.accsoft.steering.jmad.kernel.cmd.seqedit.CycleCommand;
import cern.accsoft.steering.jmad.kernel.cmd.seqedit.EndeditCommand;
import cern.accsoft.steering.jmad.kernel.cmd.seqedit.SeqeditCommand;
import cern.accsoft.steering.jmad.kernel.task.DefineAndInstallElements;

/**
 * 
 * this class generate a file to be used in a model definition
 * 
 * @author xbuffat
 *
 */

public class LhcBeamBeamFileCreator {
	
	private static final Double c = 2.99792458E8;
	
	private static final String outputFile = "../defs/resdata/lhc/install-beambeam.madx";

	private static final Integer[] collidingIP = {1,2,5,8};
	
	/*this value has to be set to generate the bunch slices -> this is not ideal! but kept for now*/
	/*Fix idea : add two more slices and then distribute the bunch according to its size*/
	private static final Double sigz = 0.077;
	/**IMPORTANT define in ascending order**/
	private static final Double[] slicePosition = {0.53 * sigz /2, 1.40 * sigz / 2};
	
	private static final Double bunchLength = 25E-9;
	
	private static final Double parasiticRange = 60.0;
	
	public static void writeFile() throws IOException {
		String toWrite = LhcBeamBeamFileCreator.getBeamBeamSequence();
		System.out.println(toWrite);
		
		String path = LhcBeamBeamFileCreator.class.getResource(outputFile).getPath();
		File file = new File(path);
		if(file.exists())
		{
			file.delete();
		}
		file.createNewFile();
	    FileWriter fstream = new FileWriter(file);
        BufferedWriter out = new BufferedWriter(fstream);
        out.write(toWrite);
        out.close();
	}


	public static String getBeamBeamSequence() {
		DefineAndInstallElements taskB1 = new DefineAndInstallElements("lhcb1",LhcBeamBeamFileCreator.getElementList(1));
		DefineAndInstallElements taskB2 = new DefineAndInstallElements("lhcb2",LhcBeamBeamFileCreator.getElementList(2));
		String retVal = LhcBeamBeamFileCreator.createHeader();
		
		retVal+=LhcBeamBeamFileCreator.cycleSequencesTo("IP3");
		
		retVal+="!\n" +
				"!sequence lhcb1\n" +
				"!\n" +
				"\n";
		retVal+=taskB1.compose();
		retVal+="\n \n" +
				"!\n" +
				"!sequence lhcb2\n" +
				"!\n" +
				"\n";
		retVal+=taskB2.compose();
		
		retVal+=LhcBeamBeamFileCreator.cycleSequencesTo("IP1");
		
		return retVal;
	}


	private static String cycleSequencesTo(String elementName) {
		SeqeditCommand sequeditB1 = new SeqeditCommand("lhcb1");
		SeqeditCommand sequeditB2 = new SeqeditCommand("lhcb2");
		EndeditCommand end = new EndeditCommand();
		CycleCommand cycle = new CycleCommand(elementName);
		
		String retVal = "!\n" +
				"! Cycle sequence to "+elementName+"\n" +
				"!\n" +
				"\n" +
				sequeditB1.compose()+"\n"+
				cycle.compose()+"\n"+
				end.compose()+"\n"+
				sequeditB2.compose()+"\n"+
				cycle.compose()+"\n"+
				end.compose()+"\n\n";
				
		return retVal;
	}


	private static String createHeader() {
		Date date = new Date();
		String retVal = "!\n" +
		"! define and install beam beam elements in sequences lhcb1 and lhcb2.\n" +
		"!\n" +
		"\n" +
		"!\n" +
		"! Autogenerated sequence from cern.accsoft.steering.jmad.modeldefs.lhc.LhcBeamBeamSequenceEditor \n" +
		"! " +date.toLocaleString()+"\n"+
		"!\n" +
		"! colliding IPs ";
		for(int i=0;i<collidingIP.length;++i)
		{
			retVal+=" "+collidingIP[i];
		}
		retVal+="\n" +
				"!\n" +
				"! slice position ";
		for(int i = 0;i<slicePosition.length;++i)
		{
			retVal+=" "+slicePosition[i];
		}
		retVal+="\n" +
				"!\n" +
				"! bunch length = "+bunchLength+" s \n" +
				"! parasitic range = " +parasiticRange+" m \n" +
				"!\n" +
				"\n";
		
		return retVal;
	}


	private static List<Element> getElementList(Integer beamNumber) {
		List<Element> retVal = new ArrayList<Element>();
		for(int i = 0;i<collidingIP.length;++i)
		{
			retVal.addAll(LhcBeamBeamFileCreator.getElementListAtIp(collidingIP[i]));
		}
		return retVal;
	}


	private static List<Element> getElementListAtIp(Integer ip) {
		List<Element> retVal = new ArrayList<Element>();
		retVal.addAll(LhcBeamBeamFileCreator.getHeadOnElementList(ip));
		retVal.addAll(LhcBeamBeamFileCreator.getLongRangeElementList(ip));
		return retVal;
	}


	//TODO retrieve position of the IP
	private static List<Element> getLongRangeElementList(Integer ip) {
		Integer count = 0;
		List<Element> retVal = new ArrayList<Element>();
		for(Double s = c*bunchLength*0.5;s<parasiticRange;s+=c*bunchLength*0.5)
		{
//			retVal.add(getDefaultBeamBeamElement("bbip"+ip.toString()+"pl"+count.toString(),new RelativePosition("IP"+ip.toString(),-s)));
//			retVal.add(getDefaultBeamBeamElement("bbip"+ip.toString()+"pr"+count.toString(),new RelativePosition("IP"+ip.toString(),s)));
			++count;
		}
		return retVal;
	}


	private static List<Element> getHeadOnElementList(Integer ip) {
		List<Element> retVal = new ArrayList<Element>();
		
//		retVal.add(getDefaultBeamBeamElement("bbip"+ip.toString(),new RelativePosition("IP"+ip.toString(),1E-9)));
		
		Integer count = 0;
		for(int i = 0;i<slicePosition.length;++i)
		{
//			retVal.add(getDefaultBeamBeamElement("bbip"+ip.toString()+"l"+count.toString(),new RelativePosition("IP"+ip.toString(),-slicePosition[i])));
//			retVal.add(getDefaultBeamBeamElement("bbip"+ip.toString()+"r"+count.toString(),new RelativePosition("IP"+ip.toString(),slicePosition[i])));
			++count;
		}
		
		return retVal;
	}
	
	private static BeamBeam getDefaultBeamBeamElement(String name,Position position)
	{
		BeamBeam retVal = new BeamBeam(MadxElementType.BEAMBEAM,name);
		retVal.setPosition(position);
		retVal.setAttribute("charge", 0.0);
		retVal.setAttributesInitialized(true);
		return retVal;
	}
	
	public static void main(String[] agrs) {
		try {
			LhcBeamBeamFileCreator.writeFile();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
}
